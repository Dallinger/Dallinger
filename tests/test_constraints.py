import os
from pathlib import Path

import pytest

from dallinger.constraints import (
    _constraints_autogenerated,
    _get_explicit_dallinger_numbered_release,
    check_constraints,
    ensure_constraints_file_presence,
    generate_constraints,
    working_directory,
)
from dallinger.utils import check_output


@pytest.fixture
def requirements_path(tempdir):
    return Path(tempdir) / "requirements.txt"


@pytest.fixture
def constraints_path(tempdir):
    return Path(tempdir) / "constraints.txt"


@pytest.fixture
def pyproject_path(tempdir):
    return Path(tempdir) / "pyproject.toml"


@pytest.mark.parametrize("uv_available_value", [True, False])
@pytest.mark.slow
class TestGenerateConstraints:
    @pytest.fixture(autouse=True)
    def mock_uv_available(self, monkeypatch, uv_available_value):
        # We test both uv and pip-compile (the fallback if uv is not available)
        monkeypatch.setattr(
            "dallinger.constraints.uv_available", lambda: uv_available_value
        )

    def test_constraints_dallinger_release(
        self, tempdir, requirements_path, constraints_path
    ):
        with open(requirements_path, "w") as f:
            f.write("dallinger==11.4.0")
        generate_constraints(tempdir)
        assert constraints_path.exists()
        assert _constraints_autogenerated(constraints_path)

        # see https://raw.githubusercontent.com/Dallinger/Dallinger/v11.4.0/dev-requirements.txt
        # # to verify that flask==3.1.1 is indeed the correct version
        assert "flask==3.1.1" in constraints_path.read_text()

    def test_constraints_dallinger_commit(
        self, tempdir, requirements_path, constraints_path
    ):
        with open(requirements_path, "w") as f:
            f.write(
                "dallinger@git+https://github.com/Dallinger/Dallinger.git@c9e0ecf554f0d6bd05b745bbf3983afdcaa848f5#egg=dallinger"
            )
        generate_constraints(tempdir)

        # see https://raw.githubusercontent.com/Dallinger/Dallinger/c9e0ecf554f0d6bd05b745bbf3983afdcaa848f5/dev-requirements.txt
        # to verify that 3.1.0 is indeed the correct version
        assert "flask==3.1.0" in constraints_path.read_text()

    def test_constraints_psynet(self, tempdir, requirements_path, constraints_path):
        with open(requirements_path, "w") as f:
            f.write("psynet==12.0.0")
        generate_constraints(tempdir)
        assert constraints_path.exists()
        dallinger_version = _get_explicit_dallinger_numbered_release(constraints_path)
        major, minor, patch = dallinger_version.split(".")

        # To verify the correct version see https://gitlab.com/PsyNetDev/PsyNet/-/blob/v12.0.0/pyproject.toml?ref_type=tags
        assert major == "11"
        assert int(minor) >= 1
        if int(minor) == 1:
            assert int(patch) >= 1

    def test_caching(self, tmpdir):
        requirements_path = Path(tmpdir) / "requirements.txt"
        requirements_path.write_text("dallinger==11.4.0")
        constraints_path = Path(tmpdir) / "constraints.txt"

        ensure_constraints_file_presence(tmpdir)

        assert constraints_path.exists()
        assert "dallinger==11.4.0" in constraints_path.read_text()

        original_mtime = os.path.getmtime(constraints_path)

        ensure_constraints_file_presence(tmpdir)

        # No change to requirements.txt so no change to constraints.txt
        assert os.path.getmtime(constraints_path) == original_mtime

        with open(requirements_path, "w+") as f:
            f.write("dallinger==10.0.0")

        # Change to requirements.txt so constraints.txt should be updated
        original_mtime = os.path.getmtime(constraints_path)
        ensure_constraints_file_presence(tmpdir)
        assert os.path.getmtime(constraints_path) > original_mtime

    def test_constraints_written_manually(
        self, tempdir, requirements_path, constraints_path
    ):
        with open(constraints_path, "w") as f:
            f.write("dallinger==11.4.0")

        original_mtime = os.path.getmtime(constraints_path)
        ensure_constraints_file_presence(tempdir)

        # Manually written constraints.txt files should not be updated
        assert os.path.getmtime(constraints_path) == original_mtime

    def test_check_constraints(self, tempdir, requirements_path, constraints_path):
        with open(requirements_path, "w") as f:
            f.write("dallinger==11.4.0")
        with pytest.raises(FileNotFoundError):
            check_constraints(tempdir)
        generate_constraints(tempdir)
        check_constraints(tempdir)


@pytest.mark.slow
def test_constraints_script_works_independently(tempdir):
    """Test that constraints.py runs when used as a self-contained script."""
    script_path = Path("dallinger/constraints.py").resolve()
    with working_directory(tempdir):
        check_output(["uv", "run", str(script_path), "generate", tempdir])
        check_output(["uv", "run", str(script_path), "check", tempdir])
        assert (Path(tempdir) / "constraints.txt").exists()
        check_output(["uv", "run", str(script_path), "ensure", tempdir])
        assert (Path(tempdir) / "constraints.txt").exists()


@pytest.mark.slow
def test_legacy_interface(tempdir):
    """Test that the legacy interface works."""
    with working_directory(tempdir):
        check_output(["dallinger", "generate-constraints"])
        assert (Path(tempdir) / "constraints.txt").exists()
